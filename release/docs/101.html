<html>

  <head>
    <script src="https://use.typekit.net/xdj4hmw.js"></script>
    <script type="text/javascript">try { Typekit.load({ async: true }); } catch(e) { }</script>

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,500" rel="stylesheet" type="text/css">
    <link rel="stylesheet" media="all" href="../style.css" type="text/css" />
    <link rel="stylesheet" media="all" href="../stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="../stylesheets/github-markdown.css" />

    <script src="../assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>
  </head>

  <body>
  <div class="backdrop tk-proxima-nova">
    <div class="header">
      <div class="header-left">Syberia</div>
      <div class="header-right">
        <ul>
          <li><a href="#">Get Started</a></li>
          <li><a href="#">Docs</a></li>
        </ul>
      </div>
    </div>
    <br /> <br /> <br />
  </div>
  <div class="colmask leftmenu tk-proxima-nova">
    <div class="colleft">
      <div class="col1">
<h1> Syberia Modeling 101 </h1>

<p>Ensure you understand the <a href="usage.html">basic usage</a> of the modeling engine
prior to proceeding.</p> 

<p>Developing classifiers using the Syberia modeling engine follows one
primary tenet: <b>development equals production</b>. When a
web developer experiments with a new website layout or feature, they
are targeting a <i>production system</i>. After they are satisfied
with their work, they push a button and deploy the code base so it
is live and others can interact with it.</p>

<p>Feature engineering and statistical modeling (as we will see,
inseparable components of machine learning) should belong to the
same class of work. When an architect designs a skyscraper their
work has to be translated to reality through a construction team 
by replaying the design using a physical medium. This is the current
industry standard for machine learning: prototype the model in
one language, typically a Python or R "notebook," and then 
write it in a "solid" "production-ready" language so it can survive
the harsh winds of the real world.</p>

<p><b>This is wrong</b>. Prior to the invention of HTML, construction of
UIs was a laborious design process that proceeded from the lab to the
factory. HTML, and later JavaScript, introduced a <i>syntax</i>, a <i>grammar</i>,
for rapidly experimenting with UIs and quickly pushing them to the
real world.</p>

<p>The tenet of using different languages for development and production
is fundamentally flawed. <i>Good syntax will always win</i> because it
records the critical mathematical abstractions relevant to the domain
and <a target="_new" href="http://asmjs.org/">retroactive optimization</a>
becomes possible.  Recoding your hardly fought experimental fruit
from R to Scala or from Python to C is a waste. Before HTML, inter-network
UIs were written in C and other lower languages. The world wide web
only exploded because it gave the power of rapid, iterative UI development
to <i>all</i> through a simple and straightforward syntax.</p>

<p>Teaching all the world's statisticians and applied mathematicians C, Java, or Scala 
to "productionize" their work is not a viable long-term strategy. The
only correct approach is to take the syntax, the mathematical notation,
most comfortable to these experts and then wielding a new world from it:
one that is alive.</p>

<p>Whether any aspect of the current Syberia framework
or its de facto modeling engine survives is irrelevant, in the same way
that VBScript ended up irrelevant, but it is important to <i>take that
  first step</i>. Do not be afraid to see real-time production-ready
hybrid stream-and-batch data processing and statistical prediction
as an <i>experimental</i> process that culminates in a finished product
the same way experimenting with a web app culminates in a deployable
real world tool <i>without additional code or re-implementation work</i>.</p>

<p>We have bothered with a philosophical prelude because we believe 
the statistician and scientist should come <i>first</i>: there
should be no "data engineer" trained in computer science and
difficult-to-master functional languages and distributed systems
to rewrite the work from scratch to make it "ready," at least to
the same extent there is no "web engineer" that takes a UI/UX expert's
JavaScript work and translates it to a C++ application every single time. All this
should be the corollary of a well-designed syntax, and the data engineering
task should be a one-time fully general abstract task that implements
that syntax in the medium of streaming distributed systems. We are
trying to find that syntax, and R's
<a target="_new" href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconicity</a>
and interactive nature forms the perfect testbed for finding that grail.</p> 

<p>Naturally, some organizations and performance-intensive applications
will continue to require full rewrites of the experimental designs, but
there is no reason why a well-designed syntax should not be capable of
auto-transpiling to the performance-optimized description, in the same
way that assembly languages were subsumed by higher abstract tools.</p>

<p>With all that said, let's jump into what a primordial first
iteration of a complete modeling grammar might look like. If you like
this approach to statistical modeling, maybe you can help us design
its future.</p>

<h2>The Basic Modeling Cycle</h2>








        </div>
        <div class="col2">
          <br /> <br /> <br />
          SIDEBAR TEXT!
        </div>
      </div>
    </div>
  </div>
</body>
