<html>

  <head>
    <script src="https://use.typekit.net/xdj4hmw.js"></script>
    <script type="text/javascript">try { Typekit.load({ async: true }); } catch(e) { }</script>

    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,500" rel="stylesheet" type="text/css">
    <link rel="stylesheet" media="all" href="../style.css" type="text/css" />
    <link rel="stylesheet" media="all" href="../stylesheets/rocco.css" />
    <link rel="stylesheet" media="all" href="../stylesheets/github-markdown.css" />

    <script src="../assets/highlight.pack.js"></script>
    <script type="text/javascript">
      hljs.initHighlightingOnLoad();
    </script>
  </head>

  <body>
  <div class="backdrop tk-proxima-nova">
    <div class="header">
      <div class="header-left">Syberia</div>
      <div class="header-right">
        <ul>
          <li><a href="#">Get Started</a></li>
          <li><a href="#">Docs</a></li>
        </ul>
      </div>
    </div>
    <br /> <br /> <br />
  </div>
  <div class="colmask leftmenu tk-proxima-nova">
    <div class="colleft">
      <div class="col1">
<h1>Stagerunner</h1>

<p>Experimenting with a data science task is usually done through
the R console or an IDE by executing portions of a file
or collection of files. Sometimes this is slightly generalized
into notebooks, interactive sessions that record the
history of the code you executed and its outputs, 
including plots, data, and summaries.</p>

<p>This kind of workflow works well in the old way, when
you don't intend on returning to your analysis for any
future use and are happy with a static image result.</p>

<p>Developers working on pure software engineering projects
usually operate in a different way: they manipulate a single
codebase and provide iterability and experimentability through
some other approach that ultimately ends up reflecting what's
in their codebase.</p>

<p>For example, a front-end web developer might change a
JavaScript file in the deep innards of a web app, hit refresh
on their browser, and test out the new functionality by clicking
their mouse.</p>

<p>To achieve a better data science workflow we will mirror
the effectiveness of the typical developer approach. 
We will rely on a <i>shared codebase</i> composed of
modular and testable resources that allows us to go back
in time using version control and have new components
vetted using code review.</p>

<p>Let's try putting the pieces of the codebase together into
a living breathing object, the same way a web browser brings a
web application alive. We'll start with a stagerunner but in
the future may end up with much more.</p>

<h2>The Execution Cycle</h2>

<div class="img-right">
  <img src="../../images/model_process.png" title="Model Process" />
</div>

<p>As mentioned earlier, a typical data science cycle begins with:
importing data, munging (cleaning) it, running a statistical classifier,
and exporting the model for validation and deployment.</p>

<p>A <b>stagerunner</b> is a single R object (specifically, an R6 object,
for those familiar with the R6 package which augments R's object-oriented
programming capabilities) that represents the full execution cycle
of the data science process. In workflows with large data sets, this
process is typically distributed across many machines in frameworks
like Spark and Hadoop. Since there is no distributed implementation
of the R interpreter (yet - shh ;) ) we focus for now on small and
medium size data problems. Typically, productionizing several 80%
solutions offers more business value than productionizing one 100% 
solution and anyway downsampling is often 
<a href="http://www.umiacs.umd.edu/~jimmylin/publications/Lin_Kolcz_SIGMOD2012.pdf">good enough</a>.</p>

<p>A stagerunner is simply a tree structure whose terminal nodes
are functions that operate on an <b>R environment object</b>. If you
are unfamiliar with R environments but understand pointers from
languages like C++, simply think of it as a pointer to a list. These
functions are executed linearly on the R environment starting with
the empty environment and culminating in side effects that export
a model, such as storing it to a backend like a cloud storage service or
a file. For the mathematically inclined, think of a stagerunner as
an element from finite sequences on the monoid of endomorphisms of R environments
with the additional meta-data of a hierarchical structure (a very
fancy way to say a list of functions that take and return
exactly one environment)</p>

<p>Some task scheduling frameworks like Luigi and Airflow take arbitrary
directed graphs of tasks and this is certainly the correct generalization
but can increase the difficulty of debugging failures in complex topologies
of tasks. Staying within a console tends to be much cozier.
Eventually Syberia may release this kind of hybrid in-console task 
scheduling and debugging but for now let's master stagerunners. (If you 
think hard enough about it, any directed graph can be decomposed into
purely serial components.)</p>

<h2>A simple stagerunner</h2>

<p>Before we jump into the convenient conventions set up by the modeling
engine that ships with Syberia by default, let's review the basics
of stagerunners.</p>

<div class="code">
  <pre>
    <code class="R"><span class="spacer">
    </code>
  </pre>
</div>




        </div>
        <div class="col2">
          <br /> <br /> <br />
          SIDEBAR TEXT!
        </div>
      </div>
    </div>
  </div>
</body>
